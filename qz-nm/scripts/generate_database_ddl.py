#!/usr/bin/env python3
"""
数据库DDL生成器
根据表结构定义生成DDL脚本
"""

import os
import sys
import json
import argparse


def parse_schema(schema_file):
    """解析表结构定义文件"""

    with open(schema_file, "r", encoding="utf-8") as f:
        return json.load(f)


def get_mysql_type(column_type):
    """将通用类型转换为MySQL类型"""

    type_mapping = {
        "STRING": "VARCHAR(255)",
        "TEXT": "TEXT",
        "INTEGER": "INT",
        "BIGINT": "BIGINT",
        "FLOAT": "FLOAT",
        "DOUBLE": "DOUBLE",
        "DECIMAL": "DECIMAL(10,2)",
        "BOOLEAN": "TINYINT(1)",
        "DATE": "DATE",
        "DATETIME": "DATETIME",
        "TIMESTAMP": "TIMESTAMP",
        "JSON": "JSON",
        "BLOB": "BLOB"
    }

    # 处理带长度的类型
    if "(" in column_type:
        return column_type

    return type_mapping.get(column_type.upper(), column_type)


def get_postgresql_type(column_type):
    """将通用类型转换为PostgreSQL类型"""

    type_mapping = {
        "STRING": "VARCHAR(255)",
        "TEXT": "TEXT",
        "INTEGER": "INTEGER",
        "BIGINT": "BIGINT",
        "FLOAT": "REAL",
        "DOUBLE": "DOUBLE PRECISION",
        "DECIMAL": "DECIMAL(10,2)",
        "BOOLEAN": "BOOLEAN",
        "DATE": "DATE",
        "DATETIME": "TIMESTAMP",
        "TIMESTAMP": "TIMESTAMP",
        "JSON": "JSONB",
        "BLOB": "BYTEA"
    }

    # 处理带长度的类型
    if "(" in column_type:
        return column_type

    return type_mapping.get(column_type.upper(), column_type)


def generate_mysql_ddl(schema, output_file):
    """生成MySQL DDL脚本"""

    ddl_lines = []
    ddl_lines.append("-- MySQL DDL Script")
    ddl_lines.append("-- Generated by Fullstack Engineer")
    ddl_lines.append("")

    for table in schema.get("tables", []):
        table_name = table["name"]
        table_comment = table.get("comment", "")

        ddl_lines.append(f"-- {table_comment}")
        ddl_lines.append(f"CREATE TABLE `{table_name}` (")

        # 生成列定义
        column_definitions = []
        primary_keys = []

        for column in table.get("columns", []):
            col_name = column["name"]
            col_type = get_mysql_type(column["type"])
            col_comment = column.get("comment", "")

            col_def = f"    `{col_name}` {col_type}"

            # 主键
            if column.get("primary", False):
                col_def += " PRIMARY KEY"
                primary_keys.append(col_name)

                # 自增
                if column.get("autoIncrement", False):
                    col_def += " AUTO_INCREMENT"

            # 非空
            if column.get("notNull", False) and not column.get("primary", False):
                col_def += " NOT NULL"

            # 唯一
            if column.get("unique", False):
                col_def += " UNIQUE"

            # 默认值
            if "defaultValue" in column:
                default_value = column["defaultValue"]
                if default_value.upper() in ["CURRENT_TIMESTAMP", "NULL"]:
                    col_def += f" DEFAULT {default_value}"
                else:
                    col_def += f" DEFAULT '{default_value}'"

            # 注释
            if col_comment:
                col_def += f" COMMENT '{col_comment}'"

            column_definitions.append(col_def)

        # 外键约束
        for column in table.get("columns", []):
            if "foreignKey" in column:
                fk = column["foreignKey"]
                fk_def = f"    FOREIGN KEY (`{column['name']}`) REFERENCES `{fk['table']}`(`{fk['column']}`)"
                if "onDelete" in fk:
                    fk_def += f" ON DELETE {fk['onDelete']}"
                if "onUpdate" in fk:
                    fk_def += f" ON UPDATE {fk['onUpdate']}"
                column_definitions.append(fk_def)

        ddl_lines.append(",\n".join(column_definitions))
        ddl_lines.append(") ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;")

        # 生成索引
        for index in table.get("indexes", []):
            index_name = index["name"]
            index_columns = ", ".join([f"`{col}`" for col in index["columns"]])
            index_comment = index.get("comment", "")

            ddl_lines.append(f"CREATE INDEX `{index_name}` ON `{table_name}` ({index_columns});")

        ddl_lines.append("")

    # 写入文件
    with open(output_file, "w", encoding="utf-8") as f:
        f.write("\n".join(ddl_lines))


def generate_postgresql_ddl(schema, output_file):
    """生成PostgreSQL DDL脚本"""

    ddl_lines = []
    ddl_lines.append("-- PostgreSQL DDL Script")
    ddl_lines.append("-- Generated by Fullstack Engineer")
    ddl_lines.append("")

    for table in schema.get("tables", []):
        table_name = table["name"]
        table_comment = table.get("comment", "")

        ddl_lines.append(f"-- {table_comment}")
        ddl_lines.append(f"CREATE TABLE public.{table_name} (")

        # 生成列定义
        column_definitions = []
        primary_keys = []

        for column in table.get("columns", []):
            col_name = column["name"]
            col_type = get_postgresql_type(column["type"])
            col_comment = column.get("comment", "")

            col_def = f"    {col_name} {col_type}"

            # 主键
            if column.get("primary", False):
                col_def += " PRIMARY KEY"
                primary_keys.append(col_name)

                # 自增
                if column.get("autoIncrement", False):
                    col_def += " GENERATED ALWAYS AS IDENTITY"

            # 非空
            if column.get("notNull", False) and not column.get("primary", False):
                col_def += " NOT NULL"

            # 唯一
            if column.get("unique", False):
                col_def += " UNIQUE"

            # 默认值
            if "defaultValue" in column:
                default_value = column["defaultValue"]
                if default_value.upper() in ["CURRENT_TIMESTAMP", "NULL"]:
                    col_def += f" DEFAULT {default_value}"
                else:
                    col_def += f" DEFAULT '{default_value}'"

            column_definitions.append(col_def)

        # 外键约束
        for column in table.get("columns", []):
            if "foreignKey" in column:
                fk = column["foreignKey"]
                fk_def = f"    FOREIGN KEY ({column['name']}) REFERENCES public.{fk['table']}({fk['column']})"
                if "onDelete" in fk:
                    fk_def += f" ON DELETE {fk['onDelete']}"
                if "onUpdate" in fk:
                    fk_def += f" ON UPDATE {fk['onUpdate']}"
                column_definitions.append(fk_def)

        ddl_lines.append(",\n".join(column_definitions))
        ddl_lines.append(");")

        # 表注释
        if table_comment:
            ddl_lines.append(f"COMMENT ON TABLE public.{table_name} IS '{table_comment}';")

        # 列注释
        for column in table.get("columns", []):
            if column.get("comment"):
                ddl_lines.append(f"COMMENT ON COLUMN public.{table_name}.{column['name']} IS '{column['comment']}';")

        # 生成索引
        for index in table.get("indexes", []):
            index_name = index["name"]
            index_columns = ", ".join(index["columns"])

            ddl_lines.append(f"CREATE INDEX {index_name} ON public.{table_name} ({index_columns});")

        ddl_lines.append("")

    # 写入文件
    with open(output_file, "w", encoding="utf-8") as f:
        f.write("\n".join(ddl_lines))


def generate_er_diagram(schema, output_file):
    """生成ER图描述文档"""

    er_lines = []
    er_lines.append("# 数据库ER图")
    er_lines.append("")

    for table in schema.get("tables", []):
        table_name = table["name"]
        table_comment = table.get("comment", "")

        er_lines.append(f"## {table_name} ({table_comment})")
        er_lines.append("")
        er_lines.append("| 字段名 | 类型 | 主键 | 非空 | 唯一 | 默认值 | 说明 |")
        er_lines.append("|--------|------|------|------|------|--------|------|")

        for column in table.get("columns", []):
            col_name = column["name"]
            col_type = column["type"]
            primary = "Y" if column.get("primary", False) else ""
            not_null = "Y" if column.get("notNull", False) else ""
            unique = "Y" if column.get("unique", False) else ""
            default = column.get("defaultValue", "")
            comment = column.get("comment", "")

            er_lines.append(f"| {col_name} | {col_type} | {primary} | {not_null} | {unique} | {default} | {comment} |")

        # 索引
        if table.get("indexes"):
            er_lines.append("")
            er_lines.append("**索引**:")
            for index in table.get("indexes", []):
                index_name = index["name"]
                index_columns = ", ".join(index["columns"])
                index_comment = index.get("comment", "")
                er_lines.append(f"- `{index_name}`: ({index_columns}) - {index_comment}")

        er_lines.append("")

    # 写入文件
    er_file = output_file.replace(".sql", "_ER.md")
    with open(er_file, "w", encoding="utf-8") as f:
        f.write("\n".join(er_lines))

    print(f"✓ 生成ER图文档: {er_file}")


def main():
    parser = argparse.ArgumentParser(description="数据库DDL生成器")
    parser.add_argument("--schema-file", required=True, help="表结构定义文件路径")
    parser.add_argument("--db-type", required=True, choices=["mysql", "postgresql"], help="数据库类型")
    parser.add_argument("--output-file", required=True, help="输出文件路径")

    args = parser.parse_args()

    # 解析表结构定义
    schema = parse_schema(args.schema_file)

    # 根据数据库类型生成DDL
    db_type = args.db_type.lower()

    if db_type == "mysql":
        generate_mysql_ddl(schema, args.output_file)
        print(f"✓ 生成MySQL DDL: {args.output_file}")

    elif db_type == "postgresql":
        generate_postgresql_ddl(schema, args.output_file)
        print(f"✓ 生成PostgreSQL DDL: {args.output_file}")

    # 生成ER图文档
    generate_er_diagram(schema, args.output_file)

    print(f"\n数据库脚本生成完成！")


if __name__ == "__main__":
    main()
