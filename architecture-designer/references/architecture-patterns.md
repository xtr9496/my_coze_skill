# 架构模式参考

## 目录
- [单体架构](#单体架构)
- [微服务架构](#微服务架构)
- [分布式架构](#分布式架构)
- [事件驱动架构](#事件驱动架构)
- [分层架构](#分层架构)
- [CQRS/Event Sourcing](#cqrs--event-sourcing)

## 概览
本文档介绍常见的架构模式及其适用场景，帮助选择合适的架构模式。

## 单体架构

### 模式描述
所有功能模块部署在同一个应用中，共享同一个数据库和内存空间。

### 适用场景
- 初创项目、快速验证 MVP
- 团队规模小（< 10 人）
- 业务逻辑简单、模块耦合度高
- 用户规模小、并发量低

### 优势
- 开发简单、快速上线
- 部署运维成本低
- 调用直接、性能好
- 事务处理简单（ACID）

### 劣势
- 扩展性差：无法独立扩展模块
- 技术栈受限：所有模块使用相同技术
- 故障影响范围大：一个模块故障影响整个系统
- 团队协作困难：代码冲突、部署协调

### 演进路径
当出现以下情况时，考虑拆分为微服务：
- 模块边界清晰、可独立部署
- 团队规模扩大、需要并行开发
- 某些模块需要独立扩展
- 技术栈需要多元化

## 微服务架构

### 模式描述
将系统拆分为多个独立的服务，每个服务负责单一业务功能，服务间通过 API 通信。

### 适用场景
- 复杂业务系统、多领域
- 团队规模大、需要并行开发
- 模块间耦合度低
- 需要独立扩展和部署
- 技术栈多元化

### 优势
- 独立部署：服务可独立发布、回滚
- 技术栈自由：不同服务可使用不同技术
- 水平扩展：按需扩展高负载服务
- 故障隔离：单个服务故障不影响全局
- 团队自治：小团队负责特定服务

### 劣势
- 分布式复杂：服务间通信、事务一致性
- 运维复杂：服务监控、日志聚合、链路追踪
- 测试复杂：集成测试、契约测试
- 数据一致性：分布式事务挑战

### 微服务拆分策略

**按业务领域拆分**（推荐）：
- 识别核心业务领域（订单、用户、商品）
- 每个领域对应一个或多个服务
- 基于 DDD（领域驱动设计）划分边界上下文

**按功能拆分**：
- 按功能模块拆分（用户服务、认证服务、通知服务）
- 适用于功能层次分明的系统

**按数据拆分**：
- 按数据实体拆分（用户数据、订单数据）
- 适用于数据隔离要求高的场景

### 技术栈
- 服务框架：Spring Boot、Spring Cloud、Dubbo
- 服务注册：Nacos、Consul、Eureka
- 配置中心：Nacos、Apollo、ZooKeeper
- API 网关：Spring Cloud Gateway、Kong、APISIX
- 服务调用：OpenFeign、Dubbo RPC
- 容错降级：Sentinel、Resilience4j、Hystrix
- 链路追踪：Zipkin、SkyWalking、Jaeger
- 日志聚合：ELK Stack（Elasticsearch + Logstash + Kibana）

## 分布式架构

### 模式描述
将系统拆分为多个节点，通过网络协同工作，提供统一的服务。

### 适用场景
- 高并发、大规模用户
- 高可用要求
- 大数据量、计算密集型
- 跨地域部署

### 核心组件
- 负载均衡：Nginx、HAProxy、LVS
- 分布式缓存：Redis Cluster
- 分布式数据库：MySQL 分库分表、MongoDB Sharding
- 分布式协调：ZooKeeper、Consul
- 消息队列：Kafka、RocketMQ

### 分布式一致性
- CAP 定理：一致性、可用性、分区容错性，三者不可兼得
- BASE 理论：基本可用、软状态、最终一致性
- 一致性方案：
  - 强一致性：分布式事务（2PC、3PC、TCC）
  - 最终一致性：事件溯源、CQRS、Saga 模式

### 典型模式
- 负载均衡：轮询、加权轮询、最少连接
- 分布式锁：Redis SetNX、ZooKeeper 临时节点
- 分布式事务：Saga、TCC、本地消息表
- 分布式 ID：雪花算法、UUID、数据库自增

## 事件驱动架构

### 模式描述
基于事件的异步通信模式，服务间通过事件消息进行解耦通信。

### 适用场景
- 异步业务流程
- 高并发削峰
- 跨系统集成
- 实时数据处理

### 核心概念
- 事件：状态变更的通知（如：订单已创建）
- 事件总线：事件传递的通道（消息队列）
- 事件处理器：订阅和处理事件的服务

### 优势
- 松耦合：服务间通过事件通信，无需直接依赖
- 异步处理：提升系统吞吐量
- 可追溯：事件日志记录系统状态变更
- 可扩展：新增事件处理器无需修改现有服务

### 劣势
- 复杂性增加：事件流程难以追踪和调试
- 最终一致性：数据一致性保证复杂
- 事件风暴：事件堆积导致系统过载

### 技术选型
- 消息队列：Kafka、RabbitMQ、RocketMQ
- 事件溯源：Event Store
- CQRS：读写分离架构

## 分层架构

### 模式描述
将系统划分为多个层次（表示层、业务层、数据层），上层依赖下层。

### 经典分层
```
表现层（Presentation Layer）
├── Controller、View
└── 负责请求处理和响应展示

业务层（Business Layer）
├── Service、Domain Model
└── 负责业务逻辑处理

数据访问层（Data Access Layer）
├── DAO、Repository
└── 负责数据持久化操作
```

### 适用场景
- 传统企业应用
- 中小型 Web 应用
- 业务逻辑清晰、层次分明

### 优势
- 职责清晰：每层有明确的职责
- 易于维护：修改某层不影响其他层
- 可测试性：每层可独立测试
- 团队协作：不同团队可负责不同层次

### 劣势
- 性能损耗：多层调用导致性能损耗
- 过度设计：简单业务可能无需复杂分层
- 级联修改：底层变更可能影响多层

## CQRS / Event Sourcing

### CQRS（Command Query Responsibility Segregation）

**模式描述**：将系统的读写操作分离，使用不同的模型处理命令和查询。

**适用场景**：
- 读多写少的系统
- 复杂查询场景
- 需要读写独立扩展

**优势**：
- 读写独立扩展
- 查询性能优化（可使用专门的查询模型）
- 复杂业务逻辑简化

**劣势**：
- 复杂度增加：需要维护两套模型
- 数据同步：写模型到读模型的同步机制
- 最终一致性

### Event Sourcing（事件溯源）

**模式描述**：不保存当前状态，而是保存所有状态变更事件，通过重放事件重建状态。

**适用场景**：
- 需要完整审计日志的系统
- 复杂业务状态管理
- 事件驱动架构

**优势**：
- 完整审计：所有变更可追溯
- 时序旅行：可重建任意时刻的状态
- 天然事件驱动：直接集成事件总线

**劣势**：
- 复杂度高：事件设计、快照管理
- 查询复杂：需要通过重放事件构建状态
- 学习曲线：团队需要理解事件驱动思想

### 技术选型
- 事件存储：Event Store、Kafka、自定义数据库
- 快照机制：定期保存当前状态，避免重放所有事件
- 投影模型（Projection）：将事件转换为查询优化的模型

## 架构模式选择指南

### 按业务规模选择
| 用户规模 | 并发量 | 推荐架构 |
|---------|--------|---------|
| < 10万 | < 1000 QPS | 单体架构 + 分层架构 |
| 10-100万 | 1000-10000 QPS | 单体架构 + 分布式缓存 |
| 100-1000万 | 1-10万 QPS | 微服务架构 + 分布式 |
| > 1000万 | > 10万 QPS | 微服务架构 + 事件驱动 |

### 按团队规模选择
| 团队规模 | 推荐架构 |
|---------|---------|
| < 10人 | 单体架构 + 分层架构 |
| 10-30人 | 微服务架构（小规模） |
| > 30人 | 微服务架构 + 领域驱动设计 |

### 按业务复杂度选择
| 业务复杂度 | 推荐架构 |
|-----------|---------|
| 简单业务、单一领域 | 单体架构 |
| 复杂业务、多领域 | 微服务架构 + DDD |
| 异步业务流程 | 事件驱动架构 |
| 强一致性业务 | CQRS + 分布式事务 |

## 架构演进路线

### 阶段 1：单体架构
- 快速验证业务
- 小团队协作
- 集中部署

### 阶段 2：分布式优化
- 引入分布式缓存
- 数据库读写分离
- 引入消息队列异步处理

### 阶段 3：微服务拆分
- 识别业务边界
- 按领域拆分服务
- 引入服务治理

### 阶段 4：云原生架构
- 容器化部署（Docker + Kubernetes）
- 服务网格（Istio）
- DevOps 自动化

### 阶段 5：事件驱动与 Serverless
- 事件驱动架构
- Serverless 函数计算
- 混合云部署

## 注意事项

- **避免过度设计**：根据实际业务选择合适的架构，不要追求新技术而引入不必要的复杂度
- **渐进式演进**：架构是演进的，不是一次性设计完成的，预留扩展空间
- **团队能力匹配**：选择的架构模式需要团队具备相应的能力，否则会带来维护灾难
- **监控与治理**：越复杂的架构越需要完善的监控和治理体系
- **文档和规范**：架构决策需要文档化，团队需要遵循统一规范
