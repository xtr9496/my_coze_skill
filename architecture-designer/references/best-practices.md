# 架构设计最佳实践

## 目录
- [高可用设计](#高可用设计)
- [可扩展性设计](#可扩展性设计)
- [安全设计](#安全设计)
- [性能优化](#性能优化)
- [监控与运维](#监控与运维)
- [数据一致性](#数据一致性)
- [容错与降级](#容错与降级)

## 概览
本文档提供架构设计的最佳实践，覆盖高可用、可扩展、安全、性能等关键领域。

## 高可用设计

### 核心原则
- **消除单点故障**：所有关键组件都需要冗余部署
- **快速故障检测**：及时发现故障并触发恢复
- **自动故障恢复**：无需人工干预即可恢复服务

### 关键实践

#### 1. 应用层高可用
**多实例部署**：
- 至少 2 个实例，避免单点故障
- 跨可用区部署，避免机房级别故障
- 容器编排（Kubernetes）自动调度

**健康检查**：
- 应用层健康检查：`/health` 端点
- 依赖服务检查：数据库、缓存、消息队列
- 负载均衡定期探测，剔除不健康实例

#### 2. 数据层高可用
**数据库主从复制**：
- 主库负责写操作
- 从库负责读操作
- 主从故障自动切换（MySQL MHA、Orchestrator）

**数据库集群**：
- MySQL Group Replication、Galera Cluster
- MongoDB Replica Set
- Redis Cluster（主从 + 哨兵）

**跨机房灾备**：
- 数据库异地灾备
- 定时备份 + 实时同步
- 灾备演练

#### 3. 基础设施高可用
**负载均衡**：
- 硬件负载均衡：F5、A10
- 软件负载均衡：Nginx、HAProxy、LVS
- 云负载均衡：AWS ELB、阿里云 SLB

**多可用区部署**：
- 跨可用区部署应用和数据
- 流量自动切换
- 依赖服务跨可用区部署

### 高可用指标
- **可用性目标**：99.9%（8.76 小时/年）、99.99%（52.56 分钟/年）
- **故障恢复时间**（RTO）：< 5 分钟
- **数据丢失容忍度**（RPO）：< 5 分钟

## 可扩展性设计

### 扩展性类型
- **水平扩展**：增加节点数量，适合无状态服务
- **垂直扩展**：提升单机性能，适合计算密集型、数据库

### 应用层扩展
- **无状态设计**：应用不保存会话状态，Session 存储在 Redis
- **自动伸缩**：根据 CPU、内存、QPS 自动增减实例
- **分布式部署**：跨多个可用区、跨数据中心

### 数据层扩展
**分库分表**：
- 水平分片：按用户 ID、时间范围分片
- 垂直分片：按业务模块分片
- 分片策略：Hash、Range、List

**读写分离**：
- 主库写、从库读
- 负载均衡路由读写请求
- 主从延迟处理

**缓存扩展**：
- Redis Cluster：自动分片、高可用
- 一致性 Hash：减少缓存迁移成本

### 扩展性设计原则
- **状态外置**：应用无状态，状态存储在外部服务（Redis、数据库）
- **服务拆分**：微服务独立扩展
- **异步解耦**：消息队列削峰填谷，提升系统吞吐量

## 安全设计

### 认证与授权
**身份认证**：
- OAuth 2.0：第三方登录（微信、支付宝）
- JWT：无状态 Token
- Session：传统 Web 应用

**权限控制**：
- RBAC（基于角色的访问控制）
- ABAC（基于属性的访问控制）
- API 级别权限：接口鉴权

### 数据安全
**加密传输**：
- HTTPS/TLS：所有 API 使用 HTTPS
- 内部服务通信：mTLS（双向认证）

**数据加密**：
- 敏感数据加密存储：手机号、身份证号
- 加密算法：AES-256
- 密钥管理：KMS（密钥管理服务）

**数据脱敏**：
- 日志脱敏：隐藏敏感信息
- 查询脱敏：手机号、银行卡号中间位隐藏

### 防护措施
**DDoS 防护**：
- 云厂商 DaaS 防护服务
- 流量清洗、IP 黑名单

**SQL 注入防护**：
- 使用参数化查询
- ORM 框架安全配置

**XSS 防护**：
- 输入过滤、输出编码
- Content Security Policy（CSP）

**CSRF 防护**：
- CSRF Token
- SameSite Cookie 策略

**API 安全**：
- Rate Limit：限流防刷
- API 签名：请求签名验证
- IP 白名单：敏感 API 限制访问

### 安全合规
- **数据保护**：GDPR、个人信息保护法
- **等保合规**：网络安全等级保护
- **日志审计**：操作日志留存 6 个月以上

## 性能优化

### 应用层优化
**代码优化**：
- 避免循环嵌套查询（N+1 问题）
- 使用连接池（数据库、HTTP、Redis）
- 异步处理：CompletableFuture、Reactive

**缓存策略**：
- 多级缓存：本地缓存（Caffeine）+ 分布式缓存（Redis）
- 缓存预热：系统启动时加载热点数据
- 缓存更新：Write-Through、Write-Behind

### 数据库优化
**索引优化**：
- 合理创建索引
- 避免 SELECT *
- 使用覆盖索引

**SQL 优化**：
- 避免大事务
- 分页查询优化（limit offset 改为 cursor）
- 批量操作代替单条操作

**连接池**：
- HikariCP（推荐）
- Druid（监控功能完善）

### 前端优化
- **静态资源 CDN**：加速静态资源访问
- **HTTP/2**：多路复用、头部压缩
- **懒加载**：图片、组件按需加载
- **压缩**：Gzip、Brotli 压缩

### 性能指标
- **响应时间**：P50 < 200ms、P99 < 500ms、P99.9 < 1s
- **并发能力**：支持预期峰值 QPS
- **资源利用率**：CPU < 70%、内存 < 80%

## 监控与运维

### 监控体系
**基础设施监控**：
- 服务器：CPU、内存、磁盘、网络
- 容器：Kubernetes、Docker
- 云服务：RDS、Elasticache

**应用监控**：
- JVM：GC、线程、堆内存
- 应用健康：健康检查、接口可用性
- 业务指标：订单量、支付成功率

**日志监控**：
- 集中日志收集：ELK Stack（Elasticsearch + Logstash + Kibana）
- 日志分级：DEBUG、INFO、WARN、ERROR
- 关键日志审计：用户操作、异常堆栈

**链路追踪**：
- 分布式追踪：SkyWalking、Jaeger、Zipkin
- 调用链路可视化：定位性能瓶颈
- 服务依赖拓扑：了解服务间依赖

### 告警机制
**告警级别**：
- P0（紧急）：系统不可用，立即处理
- P1（严重）：核心功能受影响，1 小时内处理
- P2（一般）：非核心功能异常，24 小时内处理
- P3（提示）：潜在风险，定期处理

**告警渠道**：
- 即时告警：短信、电话、钉钉、企业微信
- 邮件告警：非紧急告警
- 工单系统：P2、P3 告警创建工单

**告警收敛**：
- 避免告警风暴：同类告警聚合
- 告警抑制：依赖告警优先，避免级联告警

### 运维自动化
**CI/CD**：
- 代码自动构建、测试、部署
- 灰度发布：部分用户先使用新版本
- 自动回滚：发布失败自动回滚

**容器编排**：
- Kubernetes：自动调度、自动扩缩容
- 滚动更新：零停机发布

**故障自愈**：
- 健康检查失败自动重启
- 实例异常自动替换

## 数据一致性

### 一致性模型
- **强一致性**：CAP 中的 C，ACID 事务
- **最终一致性**：BASE 理论，允许短暂不一致
- **弱一致性**：不保证一致性，适用于特殊场景

### 分布式事务方案
**2PC（两阶段提交）**：
- 准备阶段：参与者预执行并锁定资源
- 提交阶段：协调者统一提交或回滚
- 缺点：阻塞、单点故障

**TCC（Try-Confirm-Cancel）**：
- Try：预留资源
- Confirm：确认提交
- Cancel：取消操作
- 优点：性能好、无锁
- 缺点：代码侵入、实现复杂

**Saga 模式**：
- 将长事务拆分为多个本地事务
- 每个本地事务有补偿操作
- 失败时按顺序执行补偿
- 适用于业务流程长、需要最终一致性的场景

**本地消息表**：
- 业务操作 + 写入消息表（同一事务）
- 定时任务扫描消息表，发送消息
- 消息消费重试机制
- 优点：实现简单、可靠

### 最终一致性保障
**消息重试**：
- 消息消费失败重试
- 退避策略：指数退避
- 死信队列：超过重试次数进入死信队列

**幂等性设计**：
- 幂等 Token：唯一 ID 标识请求
- 数据库唯一键：防止重复插入
- Redis 分布式锁

**数据校验**：
- 定时对账：核对数据一致性
- 数据修复脚本：发现不一致自动修复

## 容错与降级

### 容错机制
**重试**：
- 短暂故障自动重试
- 指数退避策略
- 限制重试次数

**超时**：
- 所有外部调用设置超时时间
- 连接超时、读取超时
- 快速失败原则

**熔断**：
- Sentinel： Alibaba 开源熔断降级框架
- Resilience4j：Hystrix 的继任者
- 熔断策略：错误率、慢调用比例

**限流**：
- Nginx 限流：连接数、请求速率
- 应用限流：Guava RateLimiter、Sentinel
- 限流策略：令牌桶、漏桶、固定窗口

### 降级策略
**服务降级**：
- 非核心功能降级：推荐系统、评论系统
- 默认值返回：降级时返回默认值
- 静态化页面：降级时返回静态页面

**数据降级**：
- 缓存降级：缓存不可用时查询数据库
- 数据库降级：主库不可用时切换从库（降级为读服务）
- 本地缓存：降级时使用本地缓存数据

### 隔离
**线程池隔离**：
- 不同服务使用独立线程池
- 避免某个服务故障影响整个系统
- Hystrix、Resilience4j 支持

**进程隔离**：
- 核心服务独立部署
- 非核心服务故障不影响核心服务

**机房隔离**：
- 关键服务多机房部署
- 单机房故障不影响全局

## 架构设计原则

### SOLID 原则
- **单一职责原则**：每个组件只负责一个职责
- **开闭原则**：对扩展开放，对修改封闭
- **里氏替换原则**：子类可以替换父类
- **接口隔离原则**：接口要小而精
- **依赖倒置原则**：依赖抽象而非具体实现

### DRY（Don't Repeat Yourself）
- 避免重复代码
- 提取公共逻辑
- 使用工具类、库

### KISS（Keep It Simple, Stupid）
- 保持设计简单
- 避免过度设计
- 够用即可

### YAGNI（You Aren't Gonna Need It）
- 不要实现目前不需要的功能
- 避免为未来需求过度设计

## 架构决策记录（ADR）

### 记录内容
- **背景**：需要决策的背景和问题
- **决策**：最终选择的技术方案
- **理由**：选择该方案的理由
- **后果**：决策带来的影响（正面和负面）
- **替代方案**：考虑过的其他方案

### 示例
```markdown
# ADR-001: 使用 Redis 作为缓存方案

## 背景
系统需要提升读性能，考虑引入缓存方案

## 决策
选择 Redis 作为分布式缓存

## 理由
- 丰富的数据结构（String、Hash、List、Set、ZSet）
- 高性能（10万+ QPS）
- 成熟的高可用方案（主从、Sentinel、Cluster）
- 活跃的社区和生态

## 后果
- 正面：显著提升读性能，支持复杂数据结构
- 负面：引入新的组件，增加运维复杂度

## 替代方案
- Memcached：功能单一，仅支持简单键值对
- Ehcache：本地缓存，不适用分布式场景
```

## 架构评审检查清单

### 功能性
- [ ] 所有业务需求已覆盖
- [ ] 核心流程正确
- [ ] 边界条件已处理

### 非功能性
- [ ] 高可用方案设计完成
- [ ] 可扩展性方案设计完成
- [ ] 性能指标达到要求
- [ ] 安全方案设计完成
- [ ] 监控告警方案设计完成

### 技术选型
- [ ] 中间件选型合理，有明确理由
- [ ] 技术栈与团队匹配
- [ ] 技术风险已识别并有应对措施

### 运维部署
- [ ] 部署方案清晰
- [ ] 配置管理方案完成
- [ ] 日志监控方案完成
- [ ] 灾备方案完成

### 文档与规范
- [ ] 架构文档完整
- [ ] ADR 记录完整
- [ ] 开发规范制定
